## 第一节 电子计算机的原理、发展以及应用。

　　**电子计算机**(*Computer*)亦称电脑，是利用模拟或者数字电子技术，根据一系列指令指示并且自动执行任意算术或逻辑操作串行的设备。现在电子计算机的计算模型实际上是一种通用图灵机的实现，同时是一种冯·诺伊曼结构的实现。冯·诺伊曼结构下的电子计算机由五部分构成，分别为:运算单元；控制单元；存储单元；输入单元；输出单元。

　　冯·诺伊曼架构的部件通过一组一组的排线连接，并且由一个时钟来驱动。当一组线被用于多种不同意图的数据传输时又被称为总线，同时某些其他事件也有可能驱动控制电路。存储器可以被视为一组可以存储数据的单元，而每一个存储数据的单元都是具有一个被称为地址的编号，也可以存储一段定长信息。这段定长信息既可以是指令，又可以是数据。而运算单元，或称算术逻辑单元(*ALU*),可以处理两类运算：第一类是算术运算，比如将两个数字相加或相减，有些算术逻辑单元甚至不支持电路层面的高级运算，比如乘法运算和除法运算；第二类是比较运算，比如给定两个数，比较两者谁更大。输入输出设备是计算机从外部世界进行数据交换的方法，有许多设备都能称之为输入输出设备，对于常见的微型个人计算机，常见的输入设备通常有键盘、鼠标、触摸板等，而常见的输出设备通常有屏幕、打印机等。控制单元将以上计算机各部分联系起来。它的功能是从存储器和输入输出设备中读取指令和数据，对指令进行解码， 并向ALU交付符合指令要求的正确输入，告知ALU对这些数据做哪些运算并将结果数据返回到何处。控制系统中一个重要组件就是一个用来保持跟踪当前指令所在地址的计数器。 通常这个计数器随着指令的执行而累加，但有时如果指令指示进行跳转则不依此规则。

　　在近些年来，算术逻辑单元和控制单元逐渐被集成在一块集成电路(板)上，称之为**微处理器**(*Microprocessor*)。微处理器的工作模式通常被描述为在一个时钟周期内，计算机先从存储器中获取指令和数据，然后执行指令，存储数据，再获取下一条指令的过程。而这个过程被反复执行，直至得到一个终止指令。

### 1.1.1 计算机的历史和发展

#### 1.1.1.1 计算机的历史

　　电子计算机是一步一步从计算器演化来的设备。计算机不是一个科学发现，而是一个科学和工程结合的系统工程，更是无数人共同努力的成果。从帕斯卡(*Blaise Pascal*,1623-1662)手搓出来的**加法器**到莱布尼茨(*Gottfried Wilhelm (von) Leibniz*,1646-1716)设计出来的**乘法器**，再到巴贝奇(*Charles Babbage*,1791-1871)的**差分机**(*Difference Engine No.1*)，在没有经历完整的第二次工业革命的时代里，人类的先贤以超前的思维构建了一个又一个的奇迹。直到在图灵(*Alan Mathison Turing*,1912-1954)的论文《*论可计算数及其在判定问题中的应用*》中，计算机的数学原理才被构造。他在这篇论文中，详细阐述了一项计算任务是如何被一种计算机器(*Computing Machine*)来完成的。

　　随着不断的先驱们为计算数学乃至计算科学添砖加瓦，一点一点的计算机技术被慢慢而又坚定地创造。从最初的开盘磁带，到现在的相变固态，科学技术的进步永远带领着计算机的发展；同时计算机也补充了科学技术的进步，从亨利·庞加莱(Jules Henri Poincaré,1854-1912)的研究，再到现在三体问题的计算，又到航空航天解决三体问题，计算机带动的计算力进步从而导致的科学技术发展是越来越普遍的。

　　下面，将简单给出早期计算机的历史。

***表1 早期计算机历史表***

| 时间 | 成就 |
| :---: | :----: |
| 古代中国 | 算盘 |
| 1623年 | Wilhelm Schickard构建了欧洲第一台计算设备，或称计算钟。能够完成六位数以内加减法。 |
| 1801年 | Joseph Marie Jacquard构建了史上第一台可编程设备，即Jacquard Machine。 |
| 1820年 | Charles Babbage提出了差分机的构想，即Difference Engine。遗憾的是并未建成。 |
| 1936年 | Alan Mathison Turing发表论文《On computable numbers, with an application to the entscheidungs problem》。构建了计算机的数学原理。 |
| 1937年 | Claude Elwood Shannon发表论文《A Symbolic Analysis of Relay and Switching Circuits》。构建了数字电路设计的科学原理。 |
| 1941年5月12日 | Konrad Ernst Otto Zuse构建了世界上第一台图灵完备机电一体计算机Zuse Z3，或称Versuchsmodell 3。 |
| 1941年 | 世界上第一台不可编程电子计算机被构建，即Atanasoff–Berry Computer，或称ABC计算机。 |
| 1946年 | 世界上第一台可重编程电子计算机被公布，即Electronic Numerical Integrator And Computer，或称ENIAC计算机。 |
| 1949年5月6日 | 世界上第一台冯·诺伊曼架构可重编程电子计算机被公布，即Electronic Delay Storage Auto-matic Calculator，或称EDSAC。 |
| 1949年8月 | 世界上冯·诺伊曼架构蓝本电子计算机被交付，即Electronic Discrete Variable Automatic Computer，或称EDVAC。 |
| 1951年 | 世界上第一台具有成熟操作系统的可重编程电子计算机被公布，即Whirlwind计算机。同时MIT发明了磁芯存储设备。 |
| 1952年 | IBM 701处理器问世,为IBM的第一部大型机。 |
| 1953年 | 世界上第一台晶体管图灵机问世，由Tom Kilburn在曼彻斯特大学构造。 |
| 1954年 | IBM 704机问世，IBM 650机问世。 |
| 1955年 | 世界上第一台圈晶体管图灵机问世，即Harwell CADET，于Harwell的原子能研究机构的电子部门建造。同年，Sir Maurice Vincent Wilkes发明了微码设计。 |
| 1956年 | IBM首部磁盘存储器件面世。 |
| 1957年 | IBM为IBM 704机开发了FORTRAN。 |
| 1958年 | Jack Kilby设计出第一个集成电路。|
| 1959年 | IBM 1401机。Robert Norton Noyce，仙童半导体和Intel的创始人，设计出第一个实际化的集成电路。 |
| 1962年 | 曼彻斯特大学、费伦蒂公司和普利西公司联合开发的Atlas超级电脑问世，其Atlas监督器被认为是第一个公认的操作系统。 |

##### 1.1.1.2 计算机的发展

　　电子计算机实际上是爆发式发展的，步入到晶体管时代后，由IBM和Burroughs、UNIVAC、NCR、CDC、霍尼韦尔、通用电气以及美国无线电公司主导。诸如IBM 1401、以及经久不衰的IBM System/360系列的大范围产出，以及为了性能设计而不断演化直到二进制横扫对手垄断业界，层出不穷的新设计新思想无不闪烁着数学、物理学、工程学和化学的光辉，在慢慢从大型机/超算过渡到小型机和个人电脑的过程中，DEC亦是功不可没。德州仪器和仙童半导体攻克了集成电路之后，小型机的发展成为了现实，同时因为小型机的价格低廉，很多人和机构都易于获得，而使得新的、更先进的操作系统出现，即UNIX。

　　演变中，第二代第三代计算机慢慢的被价格更低廉，来源亦是不同的第四代微型机所取代。第四代微型机源于微处理器，即大规模集成电路。微处理器起源于MOS集成电路芯片，同时因为MOSFET的快速缩小，大规模集成电路得以实现，在1971年，Intel推出了Intel 4004微处理器，正式将人类带入单片微处理器时代。而随着Intel 8008/8080/8086/8088在CP/M操作系统的成功和IBM PC的推出，微型计算机爆发式发展，IBM、Intel、Microsoft引领着中期计算机时代，而随之便迈入新世纪。

　　下面，将给出重要微处理器开发的时间表，以及计算机系统和重要硬件的时刻表。

***表2 重要微处理器开发的时间表***

| 时间 | 微处理器名称 |
| :---: | :----: |
| 1969 | Four-Phase Systems AL1 |
| 1970 | 德州仪器 TMX 1795 |
| 1971 | 德州仪器 TMS 1802NC , INTEL 4004 |
| 1972 | Fairchild PPS-25 , INTEL 8008 , Rockwell PPS-4 |
| 1973 | Burroughs Mini-D , 国家半导体 IMP-16 , NEC μCOM |
| 1974 | 通用仪器 CP1600 , INTEL 4040 , INTEL 8080 , Mostek 5065 , 摩托罗拉 6800 , 国家半导体 IMP-4 , 国家半导体 IMP-8 , 国家半导体 ISP-8A/500 , 国家半导体 PACE , 德州仪器 TMS 1000 , 东芝 TLCS-12 |
| 1975 | 仙童 F8 , HP BPC , Intersil 6100 , MOS Technology 6502 ,  RCA CDP 1801 , Rockwell PPS-8 , Signetics 2650 , 西部数据 MCP-1600 |
| 1976 | RCA CDP 1802 ,  Signetics 8X300 , 德州仪器 TMS9900 , Zilog Z80 |
| 1977 | INTEL 8085 |
| 1978 | INTEL 8086 , 摩托罗拉 6801 , 摩托罗拉 6809 |
| 1979 | INTEL 8088 , 摩托罗拉 68000 , Zilog Z8000 |
| 1980 | 国家半导体 16032 , INTEL 8087 | 
| 1981 | DEC T11 , Harris 6120 , IBM ROMP |
| 1982 | HP FOCUS , INTEL 80186 , INTEL 80188 , INTEL 80286 , DEC J-11 , Berkeley RISC-1 |
| 1983 | Stanford MIPS , Berkeley RISC-II |
| 1984 | 摩托罗拉 68020 , 国家半导体 32032 , NEC V20 |
| 1985 | DEC MicroVAX 78032 , DEC MicroVAX 78132 , Harris Novix , INTEL 80386 , MIPS R2000 |
| 1986 | NEC V60 , SUN SPARC MB86900/86910 , Zilog Z80000 |
| 1987 | Acorn ARM2 , DEC CVAX 78034 , Hitachi Gmicro/200 . 摩托罗拉 68030 , NEC V70 |
| 1988 | Apollo PRIOSM , INTEL 80386SX , INTEL i960 , MIPS R3000 |
| 1989 | DEC VAX DC520 Rigel , INTEL 80486 , INTEL i860 |
| 1990 | IBM POWER 1 , 摩托罗拉 68040 |
| 1991 | DEC NVAX , IBM RSC , MIPS R4000 |
| 1992 | DEC Alpha 21064 , HP PA-7100 , SUN microSPARC 1 |
| 1993 | IBM POWER 2, IBM PowerPC 601 , INTEL Pentium , Hitachi SuperH |
| 1994 | DEC Alpha 21064A , HP PA-7100LC , HP PA-7200 , IBM PowerPC 603 , IBM PowerPC 604 , IBM ESA/390 G1 , 摩托罗拉 68060 , QED R4600 , NEC V850 |
| 1995 | DEC Alpha 21164 , HAL Computer SPARC64 , INTEL Pentium Pro , Sun UltraSPARC , IBM ESA/390 G2 |
| 1996 | AMD K5 , DEC Alpha 21164A , HAL Computer SPARC64 II , HP PA-8000 , IBM P2SC , IBM ESA/390 G3 , MTI R10000 , QED R5000 |
| 1997 | AMD K6 , IBM PowerPC 620 , IBM PowerPC 750 , IBM RS64 , IBM ESA/390 G4 , INTEL Pentium II , Sun UltraSPARC IIs |
| 1998 | DEC Alpha 21264 , HAL Computer SPARC64 III , HP PA-8500 , IBM POWER 3 , IBM RS64-II , IBM ESA/390 G5 , QED RM7000 , SGI MIPS R12000 |
| 1999 | AMD Athlon , IBM RS64-III , INTEL Pentium III , 摩托罗拉 PowerPC 7400 |
| 2000 | AMD Athlon XP , AMD Duron , Fujitsu SPARC64 IV , IBM RS64-IV , IBM z900 , INTEL Pentium 4 |
| 2001 | IBM POWER 4 , INTEL Itanium , 摩托罗拉 PowerPC 7450 , SGI MIPS R14000 , Sun UltraSPARC III |
| 2002 | Fujitsu SPARC64 V , INTEL Itanium 2 |
| 2003 | AMD Opteron , AMD Athlon 64 , IBM PowerPC 970 , INTEL Pentium M |
| 2004 | IBM POWER 5 , IBM PowerPC BGL |
| 2005 | AMD Athlon 64 X2 , AMD Opteron Athens , IBM PowerPC 970MP , IBM Xenon , INTEL Pentium D , Sun UltraSPARC IV , Sun UltraSPARC T1 |
| 2006 | IBM Cell/B.E. , IBM z9 , INTEL Core 2 , INTEL Core Duo , INTEL Itanium Montecito |

***表3 重要计算机系统或硬件的时间***

| 时间 | 计算机系统或重要硬件 |
| 1964 | IBM 发布32位且具有内存保护的 IBM System/360 大型机 |
| 1970 | Intel 完成设计 Intel 4004 |
| 1971 | IBM 发布了 IBM System/360 大型机的后继机型， IBM System/370 。同年， Intel 发布了第一个商用微处理器，4位的 Intel 4004 。 |
| 1972 | IBM 发布了 “System/370 Advanced Function” , 增加了对虚拟内存的支持和分页的支持。 |
| 1974 | Intel 发布了第一个被广泛采用的8位微处理器 Intel 8080 。 |
| 1977 | DEC 推出了第一台32位VAX超级小型机。 |
| 1978 | Intel 推出了第一款x86芯片，也就是 Intel 8086 和 Intel 8088 。 |
| 1981 | IBM Personal Computer 发布，即 IBM PC ，现在个人电脑的最初鼻祖。同年，斯坦福 MIPS 推出了首批 RISC 设计之一的 MIPS 架构。 |
| 1985 | ARM 架构推出。 |
| 1993 | Intel Pentium 推出，这是第一款采用x86超标量微架构的处理器。 |
| 2000 | IBM 推出 z/Architecture ,作为其大型机架构的64位版本提供。同年，AMD提供了x86_86架构。 |
| 2002 | Intel 发布了第一个实现同时多线程(SMT)技术的现代处理器， Intel Pentium 4 。 |
| 2003 | AMD 发布了第一款消费级64位处理器 AMD Athlon 64 。 |

##### 1.1.1.3 IBM PC兼容机及其后继者对个人电脑市场的影响

　　IBM PC 兼容机及其后继者，指 IBM Personal Computer 、 IBM Personal Computer XT 、 IBM Personal Computer AT ， IBM Personal System/2 Series 。随着非 x86 架构的消亡，以及基于 x86 的系统慢慢标准化为 IBM PC 兼容机，市场逐渐被基于 x86 的 IBM PC 兼容机所统一。IBM 所作出的最深远的决定，便是使用开放式架构，在BIOS相同的情况下，可以自行更换其他的配件，同时搭配 IBM PC-DOS 或 Microsoft MS-DOS 。

　　为了从 8088 的适度性能中获得最佳结果，许多流行的软件应用程序都是专门为 IBM PC 编写的。这些程序的开发人员选择直接写入计算机的（视频）内存和外围芯片，绕过 MS-DOS 和 BIOS。例如，程序可能会直接更新视频刷新内存，而不是使用 MS-DOS 调用和设备驱动程序来改变屏幕的外观。许多著名的软件包，例如电子表格程序 Lotus 1-2-3 和 Microsoft 的 Microsoft Flight Simulator 1.0 ，绕过 BIOS 直接访问 IBM PC 的硬件，因此无法在与 IBM PC 稍有不同的计算机上运行，而这在电脑游戏中尤为常见。最终导致的结果，便是不完全与 IBM PC 兼容的系统无法运行该软件，并且很快就被淘汰了。与它们一起过时的是 CP/M 继承的 MS-DOS OEM 版本概念，该概念旨在（通过 BIOS 调用）在非 IBM-PC 硬件上运行。 

#### 1.1.2 计算机的原理

##### 1.1.2.1 图灵机

　　**图灵机**，即 Turing Machine 。最初是一种数学模型，是英国数学家阿伦·图灵在1936年提出的一种将人的计算行为抽象化的**数学逻辑机**，可以看作等价为任何有限逻辑数学过程的终极强大逻辑机器。

###### 1.1.2.1.1 图灵的基本思想

　　图灵的基本思想是用机器来模拟人们用纸与笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：

　　1. 在纸上写上或擦除某个符号；

　　2. 把注意力从纸的一处移动到另一处；

而在每个阶段，人要决定下一步的动作，依赖于(a)此人当前所关注的纸上某个位置的符号和(b)此人当前思维的状态。

　　为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成：

    一条无限长的纸带。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号◻表示空白。纸带上的格子从左到右依次被编号为0,1,2...，纸带的右端可以无限伸展。

    一个读写头。它可以在纸带上左右移动，能读出当前所指的格子上的符号，并能改变它。

    一套数量有限的控制规则。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态。

    按照以下顺序告知图灵机命令：

        1. 写入(替换)或擦除当前符号；

        2. 移动读写头:向左,向右或者不移动；

        3. 保持当前状态或者转到另一状态。

    一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态，称为停机状态。参见停机问题。

注意这个机器的每一部分都是有限的，但它有一个潜在的无限长的纸带，因此这种机器只是一个理想的设备。图灵认为这样的一台机器就能模拟人类所能进行的任何计算过程。 

###### 1.1.2.1.2 数学理论部分

　　一台'''图灵机'''是一个七元有序组$(Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$，其中$Q, \Sigma, \Gamma$都是有限集合，且满足:

　　　　1. $Q$是非空有穷状态集合;

　　　　2. $\Sigma$是非空有穷输入字母表，其中不包含特殊的空白符$\square$;

　　　　3. $\Gamma$是非空有穷带字母表且$\Sigma \subset \Gamma$；$\square \in \Gamma-\Sigma$为''空白符''，也是唯一允许出现无限次的字符;

　　　　4. $\delta : Q \times \Gamma \to Q \times \Gamma \times \{L, R, -\}$是转移函数，其中$L, R$表示读写头是向左移还是向右移, - 表示不移动;

　　　　5. $q_0 \in Q$是起始状态;

　　　　6. $q_{accept} \in Q$是接受状态。

　　　　7. $q_{reject}\in Q$是拒绝状态，且$q_{reject}\neq q_{accept}$。

　　图灵机$M=(Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject}) $将以如下方式运作：

　　　　从左到右依此填在纸带的第$0, 1, \ldots , n-1$号格子上，其他格子保持空白（即填以空白符$\square$);

　　　　$M$的读写头指向第0号格子;

　　　　$M$处于状态$q_0$。机器开始运行后，按照转移函数$\delta$所描述的规则进行计算。例如，若当前机器的状态为$q$，读写头所指的格子中的符号为$x$，设$\delta(q,x) =(q', x', L)$，则机器进入新状态$q'$，将读写头所指的格子中的符号改为$x'$，然后将读写头向左移动一个格子。若在某一时刻，读写头所指的是第0号格子，但根据转移函数它下一步将继续向左移，这时它停在原地不动。换句话说，读写头始终不移出纸带的左边界。若在某个时刻$M$根据转移函数进入了状态$q_{accept}$，则它立刻停机并接受输入的字符串;

　　　　若在某个时刻$M$根据转移函数进入了状态$q_{reject}$，则它立刻停机并拒绝输入的字符串。

　　注意，转移函数$\delta$是一个部分函数，换句话说对于某些$q$,$x$，$\delta(q,x)$可能没有定义，如果在运行中遇到下一个操作没有定义的情况，机器将立刻停机。

##### 1.1.2.2 冯·诺伊曼架构

　　**冯·诺依曼架构**(Von Neumann Architecture)，也称冯诺依曼模型(Von Neumann model)或普林斯顿结构(Princeton architecture)，是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。描述的是一种实现**通用图灵机**的计算设备，以及一种相对于并行计算的序列式结构参考模型(referential model)。本架构隐约指导了将存储设备与中央处理器分开的概念，因此依本结构设计出的计算机又称**存储程序计算机**。

　　冯·诺伊曼由于在曼哈顿工程中需要大量的计算，使用当时的 Mark I 和 ENIAC 时，由于繁杂的重编程操作，其意识到了在存储中程序的重要性，从而提出了储存程序式的架构。由于该词冠以冯·诺伊曼之名，对其合作伙伴和先行者，都不公平。诸如曾经的楚泽(见本章表1)设计的图灵完备程序控制式计算机以及宾夕法尼亚州大学的摩尔电机学院的许多教授与学生之间流传的本概念。

###### 1.1.2.2.1 冯·诺伊曼的基本思想

　　冯·诺伊曼架构将电脑拆分成五大组件，这在本节的最前面已经叙述过了，在此不在简单介绍。冯·诺伊曼架构最重要的思想便是将之前实现图灵机的工程实现的重新布线更改为不需要重新布线，这大大减少了使用计算机的时间成本。借由使用一套**指令集**结构，并给定每一个指令其算术或逻辑意义，从而将运算转化为指令集中的指令的序列化执行，便可以将存储设备与中央处理器分离。借由将指令作为一种特别的可修改的存储数据，一台冯诺伊曼机可以轻易的改变其程序而不需要重新布线甚至重新实现，并且其执行的程序可以在运行时同时改变。尽管随着变址寄存器和间接位置访问变成硬件结构的必备机制后，程序自行增加内容或改变程序指令的存储器位置这项功能便不如以往重要了。

　　冯·诺伊曼机将底层结构工程化实现为指令集的同时，赋予了指令以可被存储的资料的属性，从而将**汇编语言**、**编译器**以及其他自动编程工具得以实现，从而大大降低了学习计算机的能力要求。同时由于编译器的出现，高级语言得以实现。随着*Grace Murray Hopper*在1952年为A-0系统编写的第一个编译器以及1957年IBM的*John Warner Backus*领导的Fortran语言工作组向IBM交付了第一个Fortran编译器，高级语言更进一步的降低了学习计算机编程技术的门槛。

###### 1.1.2.2.2 冯·诺伊曼机的瓶颈与非冯架构

　　冯·诺伊曼机随着其特殊性迅速的占领了计算机的世界，但是不代表冯·诺伊曼机已然一统计算机界。由于冯·诺伊曼机非常依赖于存储器与中央处理器的数据交换能力，这导致了冯·诺伊曼机在处理巨量数据时会将整台冯·诺伊曼机的效率下降到非常恐怖的地步。同时计算机中央处理器的性能越来越强大，从而导致数据与存储器交换时中央处理器闲置的时间越来越长。尽管人们已经将处理器和存储器之间增加了很多层缓冲存储器，但是这个瓶颈在冯·诺依曼机上将始终存在，这便是非冯架构的必要性了。

　　非冯架构指非冯·诺伊曼架构，或者说是非程序储存式架构，这种架构最常见的例子便是计算器。由于日常生活中接触到的非冯架构事实上并不是很多，在此不再赘述。

##### 1.1.2.3 逻辑

　　本小节负责讨论计算机的逻辑。计算机的内在逻辑便是其要按照一定规则来执行一套规定的操作，而这里我们可以抛出一个其他的概念，便是**超图灵机**，指在图灵机结构内绝对不能做到的事情。由于超图灵机目前任然没有任何工程化实现，甚至没有理论依据，这里将在后面的附节简单讨论一下。

　　下面将简单讲解一下电气式二进制冯诺依曼架构图灵机的基本逻辑。

　　首先我们从其最基础的工程化实现来讨论，先从基础原理来讨论。我们不讨论什么是信息熵，只需要知道电路中最基本的两个状态分别是开和关。从电路的状态中我们可以将开和关抽象为 0 与 1 ，我们不妨把 1 定义为开， 0 定义为关，由于只能够表示 1 和 0 ，我们增加一个规则，令 1 + 1 的结果为类比十进制的 9 + 1 ，便是 10 。由于在十进制中 1 + 1 = 2 ，所以我们可以得出一个结论，在二进制中的 10 便是十进制中的 2 具体的二进制内容将在附节中给出，正文不做详述。在简单铺垫了二进制的概念之后，其基本工程实现便是各种**逻辑门**，简称**门**。逻辑门分为**与门**、**非门**、**或门**、**与非门**、**或非**和**异或门**。这些逻辑门是集成电路的基本概念组件，其输入输出表将在附节中给出，在此不在赘述。从这里我们便可以给定一个门电路，该门电路其有两个输入处，两个输出处，令电压高为开，电压低为关。定义当其输入的两个触点施加以高电压，其输出左端为高电压、右端则为低电压；当其输入的两个触点施加以低电压，其输出均为低电压；当其输入的任一触点为高电压，其输出左端为低电压、右端则为高电压。那么则称这个元器件为**加法器**。无数此类的或者相似的组件搭成同一个集成电路，然后给定一套集成电路的开关规则，这便是**机器码**。而改写复杂晦涩难记的机器码使其更易记住，便得到了**汇编语言**。

　　假设我们已经获得了这样的一套集成电路，我们设定:
        1. 地址长度为八位二进制，地址空间为 00000000 至 11111111 。其中地址 11111110 设定为汇编指令操作输出的值，地址 11111111 设定为与地址 11111110 相同但是只能随着 11111110 更改而更改的地址。
        2. 集成电路无需引导，打开电源便开始从地址空间 00000000 读取指令。
        3. 汇编指令如下:
            汇编指令 ***ADD*** 代表算术指令相加，并记录机器码为 00000000 ，其操作含义为将输入的甲地址的值与输入的乙地址的值进行算术相加计算，本指令全长 24 字；
            汇编指令 ***AND*** 代表逻辑指令　与，并记录机器码为 00000001 ，其操作含义为将输入的甲地址的值与输入的乙地址的值进行逻辑与计算，本指令全长 24 字；
            汇编指令 ***JMP*** 代表存储指令跳转，并记录机器码为 00000010 ，其操作含义为将输入的甲地址的值设定为下一条指令的地址，本指令全长 24 字；
            汇编指令 ***SET*** 代表存储指令设定，并记录机器码为 00000011 ，其操作含义为将输入的甲地址的值设定为输入的乙地址的值，本指令全长 24 字；
            汇编指令 ***EXT*** 代表存储指令跳出，并记录机器码为 00000100 ，其操作含义为不再输入下一条指令，本指令全长 8 字；
            汇编指令 ***IFF*** 代表逻辑指令比较，并记录机器码为 00000101 ，其操作含义为将输入的甲地址的值与输入的乙地址的值进行比较，若为假时进行一次跳转操作到输入的丙地址的值，本指令全长 32 字；
            汇编指令 ***IFT*** 代表逻辑指令比较，并记录机器码为 00000110 ，其操作含义为将输入的甲地址的值与输入的乙地址的值进行比较，若为真时进行一次跳转操作到输入的丙地址的值，本指令全长 32 字；
            汇编指令 ***NON*** 代表存储指令　无，并记录非已分配的机器码为此指令，其操作含义为忽略本操作到下一地址，本指令全长 8 字；

    例一. 设定程序为序列化的线性条带如下:

地址    00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 00001001 00001010 00001011 00001100 00001101 00001110 00001111
　值    00000000 00000111 11111100 00000011 00000111 11111111 00000011 00001110 11111011 00000101 11111010 11111011 00000000 00000010 11111101 10111111
翻译       A D D 00000111 11111100    S E T 00000111 11111111    S E T 00001110 11111011    I F F 11111010 11111011 00000000    J M P 11111101    N O N

地址    11110000 11110001 11110010 11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 11111100 11111101 11111110 11111111
　值    01010010 00011011 11110101 00100001 10111111 01010010 01010010 00011011 11110101 00100001 10111111 11111111 00000001 00000100 EEEEEEEE EEEEEEEE
翻译       N O N    N O N    N O N    N O N    N O N    N O N    N O N    N O N    N O N    N O N    N O N 11111111 00000001    E X T EEEEEEEE EEEEEEEE

　　　　解释这个程序是做了什么？

　　　答: 这是一个将内存地址 00001111 到 11111010 设定为地址 11111011 的值的程序。该程序自地址 0000000 开始运行，首先根据操作算术相加将地址 00000111 的值与地址 11111100 的值相加并放在地址 11111110 中；然后根据操作设定将地址 11111111 的值转移到地址 00000111 中；接着根据设定将地址 00000111 的值的地址设定为地址 11111011 的值；然后进行一次真假判断，如果地址 11111010 的值等于地址11111011 的值，则进行一次跳转操作，跳转到地址 11111101 处执行跳出指令，终止程序，否则将跳转到地址 00000000 来重复执行。

###### 1.1.2.3.1 超图灵机

　　**超图灵机**，指的是一类可进行不可图灵计算问题的求解一类的问题的数学逻辑机器，这一类有常见的有**神谕机**以及**逆时序计算机**。我们适当扩大超图灵机的定义，将超图灵机增加其实现后，我们便可发现超图灵机的几点属性。在可图灵计算问题中，需要给定一个规则，同时要给定一个输入输出，还需要在有限步内执行结束。在跳出图灵计算的框架后，我们可以发现超图灵机能够支持以下情况的存在:

        1. 超图灵机能够支持在不输入任何消息的情形下自主输出所需要的结果；
        2. 超图灵机能够支持在输入消息后越过无穷步后直接给出输出结果，或者说立即给出结果；
        3. 超图灵机能够给出不可能以任何非超图灵机给出的结果；

　　根据以上情况，我们可以得出以下事实: 超图灵机能够给出消息越过无穷步之后的结果，以至于其可以规避任何信息传递的极限，从而使得可以计算完毕一个无穷大数，如圆周率和自然对数的底，或者说，直接给出一个无穷大数；而我们同时也知道，超图灵机能够计算非图灵可解问题，或者说能够解决非数学逻辑问题，则可以做以下类推：超图灵机能够给出宇宙的任何一个瞬间的任何状态，从这里我们可以抽象出另一种类型的计算机，或称为**逆时序计算机**；从以上一个情况我们也可以看出，超图灵机能够做到预测未来，或者说改变过去，这样超图灵机事实上可以做到无中生有任意一个物品或资料。

　　我们再来谈谈神谕机。我们假设神谕机是一个终端，其主服务器为全知的神。这样我们就可以做到上文所说的情况 2 ，即能够越过无穷步立即给出结果。神谕机能够无视图灵计算过程，甚至可以无视计算而直接给出所需要的数据，或者说，真理。

　　不妨再转变一个思路，我们来谈谈逆时序计算机。逆时序计算机可以是图灵机，甚至可以是冯诺依曼机，其算超图灵机的一种特例。逆时序计算机的计算过程是在*未来*，计算结束后向*过去*发出消息。由于计算结果已经给出，则可以认为未来的计算过程已经不再存在。

###### 1.1.2.3.2 逻辑门



###### 1.1.2.3.3 二进制



## 参考文献

《On computable numbers，with an application to the entscheidungs problem》 - Alan Mathison Turing,1936. | DVD-DL\Documents\On computable numbers，with an application to the entscheidungs problem - A. M. Turing.pdf

《A Symbolic Analysis of Relay and Switching Circuits》 - Claude Elwood Shannon,1937. | DVD-DL\Documents\A Symbolic Analysis of Relay and Switching Circuits - C. E. Shannon.pdf

## 来源

　　许多内容来自于维基百科，在此感谢其写作者。由于笔者能力有限，许多数学内容无法解释，还望见谅。基于CC BY-SA 4.0的协议下，许多内容都进行过适当的修改以符合语境。以下含有大面积的引用/修改:

　　　　1. #1.1.1.3 IBM PC兼容机及其后继者对个人电脑市场的影响 第二段，来自维基百科该词条。经过翻译。

　　　　2. #1.1.2.1 图灵机，来自维基百科该词条。由于笔者数学功力极为有限，不得已如此，如有数学专业的同仁见此欲重写，笔者欢迎。

　　　　3. #1.1.2.2 冯·诺伊曼机 第一段，来自维基百科该词条。